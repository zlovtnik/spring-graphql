spring:
  application:
    name: ssf
  datasource:
    url: jdbc:oracle:thin:@//${ORACLE_HOST:localhost}:${ORACLE_PORT:1521}/${ORACLE_DB:FREEPDB1}
    driver-class-name: oracle.jdbc.OracleDriver
    username: ${ORACLE_USER:ssfuser}
    password: ${ORACLE_PASSWORD:ssfuser}
    hikari:
      connection-timeout: 30000
      maximum-pool-size: 20
      minimum-idle: 5
      auto-commit: true
      validation-timeout: 5000
      leak-detection-threshold: 60000
      max-lifetime: 1800000
      idle-timeout: 600000
      connection-test-query: SELECT 1 FROM DUAL
      data-source-properties:
        oracle.jdbc.fanEnabled: true
        oracle.jdbc.fastConnectionFailover: true
        oracle.net.CONNECT_TIMEOUT: 10000
        oracle.net.READ_TIMEOUT: 60000
        oracle.jdbc.implicitStatementCacheSize: 25
        oracle.jdbc.maxCachedBufferSize: 65536
  jpa:
    database-platform: org.hibernate.dialect.OracleDialect
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.OracleDialect
        jdbc:
          batch_size: 100
          fetch_size: 50
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=500,expireAfterWrite=10m,recordStats
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD}
      timeout: 2000ms
      database: 0

# Cache Service Configuration
# Configures individual cache behavior (query result cache and session cache)
# Properties are read by CacheConfiguration class using Spring's @ConfigurationProperties
cache:
  config:
    # Query Result Cache: caches GraphQL/database query results
    query-result-cache:
      max-size: 1000                  # Maximum number of cache entries
      ttl-minutes: 15                 # Time-to-live in minutes before entries expire
    
    # Session Cache: caches user session data
    session-cache:
      max-size: 5000                  # Maximum number of cache entries
      ttl-minutes: 60                 # Time-to-live in minutes (1 hour)

server:
  port: 8443
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: ${KEYSTORE_PASSWORD:changeit}
    key-store-type: PKCS12
    key-alias: ssf

# Batch operations configuration
batch:
  size: 200                          # Default batch size (100-500 based on memory profiling)
  max-retries: 3                     # Max retries with exponential backoff
  initial-retry-delay-ms: 100        # Initial retry delay in milliseconds
  memory-threshold-percent: 80       # Trigger batch size reduction at 80% heap usage

app:
  jwt:
    secret: ${JWT_SECRET}
  security:
    enable-default-user-role: false  # Least-privilege: no implicit roles unless explicitly enabled
  minio:
    url: http://localhost:9000
    access-key: ${MINIO_ACCESS_KEY}
    secret-key: ${MINIO_SECRET_KEY}
  cache:
    default-max-age: 3600             # Default Cache-Control max-age in seconds (1 hour)


management:
  endpoints:
    web:
      exposure:
        include: ${MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE:health,metrics}
  endpoint:
    health:
      show-details: when-authorized